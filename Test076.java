/*===============================
  ■■■ 클래스와 인스턴스 ■■■
  - 생성자(constructor)
  ===============================*/


public class Test076
{
	int x;

	// ※ 생성자의 이름은 항상 예외없이 클래스의 이름과 동일해야 하며
	//	  필요할 경우 인수를 받아들이는 것도 가능하고,
	//	  같은 이름의 메소드를 정의하는 중복정의가 가능하지만
	//	  리턴값(반환값)은 가질 수 없다.

	// ※ 생성자는 다른 일반 메소드들처럼 호출될 수 없고
	//	  『new』연산자를 이용하여 객체를 생성하기 위해 호출되며,
	//	  각 클래스의 인스턴스인 객체를 생성한 후에
	//	  생성된 객체의 멤버를 초기화시키는 작업을 수행한다.

	// ※ 예습!!!
	//	  클래스변수 == static 변수 == 정적 변수



	Test076()
	{
		// ※ 생성자 내부에서 다른 생성자를 호출하는 것은 가능하다.
		//	  하지만, 생성자 내부에서 가장 먼저 실행되어야 한다.
		//	  아래와 같이 Test076.Test076 이런 식은 클래스변수가 선점함
		//	  고로 this 써라.
		this(100);

		x = 10;
		System.out.println("인자가 없는 생성자");
		System.out.println("Test076이 갖고 있는 x : " + x);
	}

		// ※ 메소드 오버로딩 : 메소드 이름은 같지만 하는 기능이 다른 녀석들
		//	  주의 할 점은 꼭 '파라미터' 가 달라야 함! 파라미터가 다르고 기능은 같아도 가능!!!!

	Test076(int x)
	{
		// ※ 이 경우 x 는 지역변수를 우선적으로 받게 된다.
		//	  이 지역변수 x 를 전역변수 x 로 대입하기 위해서는
		//	  Test076.x = x 라는 형식으로 써야 하지만 이것은 '클래스 변수'라는 녀석이 선점했어
		//	  그렇기 때문에 this 라는 녀석을 사용하여 this.x = x 라고 표기하면 됨.

		// ※ this 라는 키워드를 어느 코드에서든 보게 되면 가장 가까이 둘러싸고 있는 클래스를 확인할 것

		// ※ x=x 일 때 parameter를 100을 받게 되면 100=100 꼴이 되어버려
		x = x;
		System.out.println("인자가 하나인 생성자");
		System.out.println("Test076이 갖고있는 x : " + this.x);
	}

	public static void main(String[] args)
	{
		// Test076 클래스 기반 인스턴스 생성
		Test076 ob1 = new Test076();
		Test076 ob2 = new Test076(100);

		System.out.println("main 에서 ob1.x : " + ob1.x);
		System.out.println("main 에서 ob2.x : " + ob2.x);

	}
}